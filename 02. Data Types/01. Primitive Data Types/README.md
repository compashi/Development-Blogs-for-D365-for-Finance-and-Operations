# Primitive Data Types

## Introduction 

A data type is a placeholder specifying what kind of value can a variable accept.

The primitive data types in X++ are listed in the following table:

| Data type   | Keyword     | Description |
| ----------- | ----------- | ----------- |
| Anytype     | anytype     | A placeholder for any data type |
| Boolean     | boolean     | Can only contain values **true** and **false** |
| Date        | date        | Contains **day**, **month** and **year** |
| Enum        | -           | Fixed set of literals referenced by a integer |
| Guid        | guid        | Global unique identifier |
| Integer     | int         | Number without decimal point |
| Real        | real        | Number with a decimal point |
| String      | str         | Number of characters |
| TimeOfDay   | timeOfDay   | Contains **hours**, **minutes** and **hours** |
| UtcDateTime | utcdatetime | Contains both `timeOfDay` and `date` |

### Anytype 

The **anytype** data type is a placeholder for any data type. Standards suggest that **anytype** variables should only be used as parameters or return types. 

A **anytype** variable once defined, can't be redefined with another data type, else a run-time error will be generated by the system. The following table shows the property of the **anytype** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **anytype** |
| Size          | Depends on conversion type |
| Scope         | Depends on conversion type |
| Default Value | Depends on conversion type |
| Implicit Conversion | Automatically converts on first assignment |
| Explicit Conversion | `any2date`, `any2enum`, `any2int`, `any2real` and `any2str` |

The following example shows how to use **anytype** data type:

```c++
public static str range(anytype _from, anytype _to) 
{
    return queryValue(_from) + '..' + queryValue(_to);
}
```

```c++
void put(int position, anytype data)
{
    record = conpoke(record, position, data);
}
```

### Boolean 

The **boolean** data type is used to test whether a statement is **true** or **false**. These are also known as logical expressions. The X++ internal representation of **boolean** is an **integer**, any value other than 0 is treated as **true**, otherwise **false**. The following table shows the property of the **boolean** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **boolean** |
| Size          | 8 bits (1 byte) |
| Scope         | **false** (0) or **true** (1) |
| Default Value | **false** |
| Implicit Conversion | Automatically converts to **int**, **date** and **real** |
| Explicit Conversion | none |

The following example shows how to use **boolean** data type:

```c++
void main()
{
    boolean expr;
    
    expr = (6*7==42);
    
    if (expr) 
    {
        info("true");
    } 
    else
    {
        info("false");
    }
}
```

### Dates

A **date** data type holds a complete date i.e. day, month and years. The **date** data type can hold values from 1st Jan 1900 till 31st Dec 2154 inclusive i.e. [1\1\1900 : 31\12\2154]. The following table shows the property of the **date** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **date** |
| Size          | 32 bits (4 byte) |
| Scope         | [1\1\1900 : 31\12\2154] |
| Default Value | 1\1\1900, which is treated as **null** by X++ SQL statements |
| Implicit Conversion | none |
| Explicit Conversion | `date2str` and `date2num` |

The following example shows how to use **date** data type:

```c++
void myMethod()
{
    int days;
    date someDate;
    
    days = 30;
    someDate = 1\1\1998;
    
    someDate += 30;     // new date is 31\1\1998
}
```

### Enum

An enum is a list of literals that can referred by integer values. The first element has value 0, the second element has value 1, and so forth. There are alot of built in enum to aid in development, such as `NoYes`. A single enum can hold a total of 255 elements ranging from 0 to 254. 

To reference an enum literal, the name of the literal is used, seperated by double colons: `EnumName::literalName`. The table shows how property of an enum data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | none |
| Size          | 8 bits (1 byte) |
| Scope         | User defined |
| Default Value | 0 for first literal |
| Implicit Conversion | Automatically converted to **int**, **boolean** and **real** |
| Explicit Conversion | `enum2str` |

The example shows how to use enum data type:

```c++
public void myFunc()
{
    NoYes completed = NoYes::No;

    if (completed==0) 
    {
        // do something
    }
}
```

### GUID

A **GUID** (globally unique identifier) is a 128 bits (16 bytes) long unique identifier which has a very low probability of being duplicated. The reason for creating a **GUID** is to use it across over all computer and networks. The function `newGuid` is used to create a random guid value. The following table shows the property of **GUID** data type:

| Name             | Description |
| ---------------- | ----------- |
| Keyword          | **guid**    |
| Number of Digits | Must have 32 hexadecimal digits |
| Format           | 8-4-4-4-12 |
| Braces           | Options to have braces {} |
| Length           | 36 or 38 characters, depending on if braces are added |
| Casing           | [a-f], [A-F], [0-9] |
| Explicit Conversion | `guid2str`, `Global::guidFromString` and `Global::stringFromGuid` |

The following example will show how to use **guid** data type::

```c++
public void myFunc()
{
    guid randGuid = newGuid();
    guid strGuid = str2guid("BB345678-abcd-0000-ABCD-bbccddeeff12");
    guid braceGuid = str2guid("{BB345678-abcd-0000-ABCD-bbccddeeff12}");
}
```

Note: `guid2str` method automatically adds braces to a string even if braces weren't defined for a guid.

### Integer

**Integers** are numbers without a decimal. X++ has two **integer** types:

- **int**, which is 32 bits wide i.e. ranging from  [-2,147,483,648 : 2,147,483,647]
- **int64** which is 64 bits wide i.e. ranging from [-9,223,372,036,854,775,808 : 9,223,372,036,854,775,807]

**Integer** literals can be used anywhere in the code, note that to use values greater than 2147483647, the letter u should be placed at the end of the literal, otherwise it will be treated as a 32-bit number rather than a 64-bit one. The following table shows the property of **int** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **int**, **int64** |
| Size          | 32/64 bits (4/8 byte) |
| Scope (int)   | [-2<sup>31</sup> : 2<sup>31</sup>-1] |
| Scope (int64) | [-2<sup>63</sup> : 2<sup>63</sup>-1] |
| Default Value | 0 |
| Implicit Conversion | Automatically converted to **real**, **boolean** and **enum** |
| Explicit Conversion | `int2str` and `int642str` |

The following example shows how to use **int** data type:

```c++
void myFunc()
{
    int i=1, j=2;
    
    j+= (i+i) div 2;
    
    if (j>2) 
    {
        info("j is greater than 2");
    }
    else 
    {
        info("j is not greater than 2");
    }
}
```

### Real

**Real** variables hold decimal and non decimal values. They are stored as Binary coded decimal (BCD encoding), which allows to make exact representations of values that are multiples of 0.1. Due to their implementation they can also be expressed using exponential notation. The following table shows the property of **real** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **real** |
| Size          | 64 bits (8 byte) |
| Scope         | -10<sup>127</sup> : 10<sup>127</sup> |
| Default Value | 0.00 |
| Implicit Conversion | Automatically converted to **int**, **boolean** and **enum** |
| Explicit Conversion | `num2str` |

The following example shows how to use **real** data type:

```c++
void myMethod()
{
    real v1 = 1.25;
    real v2 = 1.000e3;
    real v3 = 1.2345e+3;
    real v4 = 1.0e;
    real v5 = 1.2345e-5;
}
```

### String

Sequence of characters make up a **string**. X++ allows you to either store infinitely long string or allows you to predefine and fix the length of the variable. **Strings** must be enclosed in double quotataions where ever **string** literals are expected. The following table shows the property of **string** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **str** |
| Size          | Dynamic or fixed length |
| Scope         | Unlimited |
| Default Value | "" (empty) |
| Implicit Conversion | none |
| Explicit Conversion | `str2int`, `str2int64`, `str2num`, and `str2date` |

The following example shows how to use **str** data type:

```c++
void myMethod()
{
    str infinteLengtString;
    str 10 stringWithLength10;
    
    string hello = "hello, ";
    string world = "world!";
    
    info(strFmt("%1%2", hello, world));    // prints "hello, world!"
}
```

### Time of Day

**timeOfDay** or time data type is an integer that represents how many seconds have passed since midnight. **timeOfDay** is represented as integer, but can be represented as a string (12:00:00) as long as its converted from string to **timeOfDay**. The following table shows the property of **timeOfDay** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **timeOfDay** |
| Size          | 32 bits (4 byte) |
| Scope         | [0 : 86400] |
| Default Value | 0 |
| Implicit Conversion | Automatically converted to **real**, **boolean**, and **enum** |
| Explicit Conversion | `time2str` |

The following example shows how to use **timeOfDay** data type:

```c++
void myMethod()
{
    timeOfDay time = 0;
    
    time += 3600;   // 1 hour added
}
```

### utcdatetime

**utcdatetime** is a combination of date and timeOfDay data type. **utcdatetime** holds the advantage of holding time zone information, allowing it to be used globally. Tables shouldn't opt for **utcdatetime** field, but rather an EDT that extends **utcdatetime**, since **utcdatetime** doesn't have a TimezonePreference property. The following table shows the property of **utcdatetime** data type:

| Name          | Description |
| ------------- | ----------- |
| Keyword       | **utcdatetime** |
| Precision     | smallest value is one second |
| Format        |  yyyy-mm-dd-Thh:mm:ss |
| Default Value | 1900-01-01T00:00:00, treated as null during conversion and with X++ SQL statements |
| Minimum Value | 1900-01-01T00:00:00 |
| Maximum Value | 2154-12-31T23:59:59 |

The following example shows how to use **utcdatetime** data type:

```c++
void myMethod()
{
    int         iDay   = DateTimeUtil::day(1988-07-20T13:34:45)
    utcdatetime myUtc2 = 1988-07-20T13:34:45;
    utcdatetime myUtc4 = DateTimeUtil::parse("1988-07-20T13:34:45");
}
```

## References

- [Primitive Data Types](https://msdn.microsoft.com/en-us/library/aa602290.aspx)
- [Anytype](https://login.live.com/login.srf?wa=wsignin1.0&rpsnv=13&checkda=1&ct=1504005083&rver=6.7.6640.0&wp=MCMBI&wlcxt=msdn%24msdn%24msdn&wreply=https%3a%2f%2fmsdn.microsoft.com%2fen-us%2flibrary%2faa853001.aspx&lc=1033&id=254354&mkt=en-US)
- [Booleans](https://msdn.microsoft.com/en-us/library/aa659760.aspx)
- [Dates](https://msdn.microsoft.com/en-us/library/aa865135.aspx)
- [Enums](https://msdn.microsoft.com/en-us/library/aa881702.aspx)
- [GUIDs](https://msdn.microsoft.com/en-us/library/cc967363.aspx)
- [Integer](https://msdn.microsoft.com/en-us/library/aa851966.aspx)
- [Real](https://msdn.microsoft.com/en-us/library/aa878630.aspx)
- [String](https://msdn.microsoft.com/en-us/library/aa889472.aspx)
- [Time of Day](https://msdn.microsoft.com/en-us/library/aa674480.aspx)
- [utcdatetime](https://msdn.microsoft.com/en-us/library/cc597805.aspx)